# The goal is to get the path

- construct own traversal graph
- start in room 0 which contains exits ['n', 's', 'w', 'e']

    {
      0: {'n': '?', 's': '?', 'w': '?', 'e': '?'}
    }

    {
      0: {'n': '?', 's': 5, 'w': '?', 'e': '?'},
      5: {'n': 0, 's': '?', 'e': '?'}
    }

    Start by writing an algorithm that picks a random unexplored direction from the player's current room,
    travels and logs that direction, then loops.

    This should cause your player to walk a depth-first traversal. When you reach a dead-end (i.e. a room with no unexplored paths),
    walk back to the nearest room that does contain an unexplored path.

    You can find the path to the shortest unexplored room by using a breadth-first search for a room with a '?' for an exit.

    If you use the bfs code from the homework, you will need to make a few modifications.

    Instead of searching for a target vertex, you are searching for an exit with a '?' as the value.
    If an exit has been explored, you can put it in your BFS queue like normal.

    BFS will return the path as a list of room IDs. You will need to convert this to a list of n/s/e/w directions before you can add it to your traversal path.



    # STEP 1:

    # Create an empty queue
        # add a PATH TO the starting vertex_id to the queue
        # create an empty dictionary to store visited users and social paths
        # while the queue is not empty...
            # dequeue, teh first path
            # Grab the last vertex from the path
            # check if it's been visited
            # if it has not been visited...
                # mark it as visited
                    # add it to the visited set, with the path as the key
                # then add all friends to the back of the queue
                    # copy the path
                    # add friend to the path