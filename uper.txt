# The goal is to get the path

- construct own traversal graph
- start in room 0 which contains exits ['n', 's', 'w', 'e']

    {
      0: {'n': '?', 's': '?', 'w': '?', 'e': '?'}
    }

    {
      0: {'n': '?', 's': 5, 'w': '?', 'e': '?'},
      5: {'n': 0, 's': '?', 'e': '?'}
    }

    Start by writing an algorithm that picks a random unexplored direction from the player's current room,
    travels and logs that direction, then loops.

    This should cause your player to walk a depth-first traversal. When you reach a dead-end (i.e. a room with no unexplored paths),
    walk back to the nearest room that does contain an unexplored path.

    You can find the path to the shortest unexplored room by using a breadth-first search for a room with a '?' for an exit.

    If you use the bfs code from the homework, you will need to make a few modifications.

    Instead of searching for a target vertex, you are searching for an exit with a '?' as the value.
    If an exit has been explored, you can put it in your BFS queue like normal.

    BFS will return the path as a list of room IDs. You will need to convert this to a list of n/s/e/w directions before you can add it to your traversal path.